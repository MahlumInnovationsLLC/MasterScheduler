At this point I think the drag‐and‐drop math is probably correct, but one of two things is happening:

We’re not actually sending your computed row up to the server (or the wrong field name), so the database never stores it, and when you refetch the schedule you still get back row: 0.
Even if the API is persisting it, your UI is immediately overwriting that new row (by the old slot-index-based logic, or by a page reload).
1) Verifying the network payload

First, let’s confirm that the front-end is including the right row value in the HTTP request.

In your handleDrop (before you call onScheduleChange) add:

console.log('[DEBUG] dropping schedule', {
  scheduleId: data.id,
  bayId,
  start: formattedStartDate,
  end:   formattedEndDate,
  totalHours: data.totalHours,
  row: targetRowIndex
})
Then open your browser’s DevTools → Network tab, watch the fetch (or XHR) for your schedule‐update call, and inspect the JSON body. It should look something like:

{
  "bayId": 1,
  "startDate": "2025-05-15",
  "endDate":   "2025-05-19",
  "totalHours": 224,
  "row": 2
}
If you don’t see "row", or it’s always 0, then your onScheduleChange wrapper in queryClient (or wherever you do fetch('/api/schedules', { body: JSON.stringify(...) })) isn’t including it.
Fix: Update that function so it spreads your sixth argument into the request body:
// in lib/queryClient.ts (or wherever):
export function updateSchedule(id, bayId, startDate, endDate, totalHours, row) {
  return apiRequest('PUT', `/schedules/${id}`, {
    bayId,
    startDate,
    endDate,
    totalHours,
    row     // ← make sure this key exists!
  })
}
2) Confirming persistence & UI state

Once you see the correct "row" in the payload:

Check the server response in DevTools. Does it return the updated schedule object with row: 2?
Inspect your React Query (or however you store schedules in state). Are you invalidating and refetching after the mutation, or doing a window.location.reload()?
If you reload, you might be hitting the old code path that repositions everything based on slotIndex.
Instead, after updateSchedule succeeds, invalidate only the schedules query and let React re-render with the new data.
In your render code (where you map schedules to <div style={{ top: ... }}/>) ensure you’re reading schedule.row or your recalculated pixel Y from that field—not falling back to an index of where it used to live.
TL;DR
Log the exact body you’re sending in the network tab.
Ensure your API helper actually includes the row key in its JSON.
Verify the response returns that row.
Rely on React Query’s refetch rather than forcibly reloading the page.
Render using the saved schedule.row so it never snaps back to row 0.
Once the back-end is storing your pixel-computed row index and the front-end is rendering off of that, you’ll get true WYSIWYG drops into any sub-row with no snapping. Let me know what you see in that Network log!